#### 定义函数

    fn add(i: i32, j: i32) -> i32 { // 细尖头符号表示返回，
        i + j
    }

- Rust的函数定义，要求你必须显式的指定函数参数的类型和返回值的类型。

#### 使用引用

- 引用是一个用于指代另一个值的值。使用引用操作符（&）创建出来的，而执行解引用则需要使用解引用操作符（*）

``` rust
// 例子一
fn main() {
    let a = 42;
    let r = &a;
    let b = a + *r;
    println!("a + a = {}", b)
}

// 例子二
fn main() {
    let needle = 0o204;
    let haystack = [1, 1, 2, 5, 15, 52, 132, 877, 4140, 21147];
    for item in &haystack { // 在数组haystack中遍历数组元素的引用
        if *item == needle { // *item这个语法解引用item，返回它所指向的对象
            println!("{}", item);
        }
    } // 每一次迭代都会改变item的值，指向haystack下一个元素的值
}
```

#### 高级函数定义

- ###### 显式生命周期注解
  所有绑定到一个给定的生命周期的值，必须与最后一次访问绑定到该生命周期的任何值"活"得一样长。  
  尽管每个函数都有一个生命周期，但这些检查通常是不可见的，也就是说，这些生命周期通常不需要出现在代码中，因为编译器可以推断出大部分参数的生命周期（省略掉生命周期注解，正式的说法叫做生命周期省略）。但是在一些推断生命周期有困难的情况下，编译器就需要协助了，比如：函数接收多个引用参数，还有当函数返回一个引用值时，编译器在需要协助时，通常会通过一个错误信息来表示。

``` rust
fn main() {
    let a = 10;
    let b = 20;
    let res = add_with_lifetimes(&a, &b); // 在调用含有生命周期函数时，生命周期注解不是必须的
    println!("{}", res)
}

// <'a, 'b> 声明了两个生命周期变量，'a 'b 通常称为生命周期a，生命周期b
// i: &'a i32 把生命周期变量'a绑定到i的声明周期上，读作"i是一个i32的引用，具有生命周期a"
// j: &'b i32 把生命周期变量'b绑定到j的声明周期上，读作"j是一个i32的引用，具有生命周期b"
// 在此代码中分别使用了两个生命周期参数（a，b）表示i，j的生命周期是解藕的。
fn add_with_lifetimes<'a, 'b>(i: &'a i32, j: &'b i32) -> i32 {
    *i + *j
}

```

#### 泛型函数

- 在类型注解的位置上使用大写字母来表示一个泛型类型。依照惯例，经常使用T、U、V来作为泛型类型的占位符，但实际上也可以是任意其他名字。E经常用来表示错误类型

``` rust
fn add<T>(i: T, j: T) -> T { // 代表类型变量T是使用尖括号来引入的<T>。这个函数接收两个同类型的参数并返回一个相同类型的值
    i + j
}
```

- 带trait限定的泛型函数
    - <T: std::ops::Add<Output=T>>表示要求T必须实现std::ops::
      Add。在这个trait限定中，使用了单个类型变量T，这保证了函数参数i和j以及函数的结果都是同一个类型，并且他们的这个类型是支持加法运算的。
    - 所有rust的操作符都是使用trait定义的，例如加法操作符（+）是作为std::ops::Add
      trait来定义的。rust操作符均为某个trait的语法糖，rust使用这种方式支持了操作俯重载。在编译过程中a+b会被转换为a.add(b)

``` rust

fn add<T: std::ops::Add<Output=T>>(i: T, j: T) -> T { // 代表类型变量T是使用尖括号来引入的<T>。这个函数接收两个同类型的参数并返回一个相同类型的值
i + j
}

```

#### ！类型（Never类型）

- ！类型叫做Never类型。Never用于表示一个函数用不返回，下面有两个例子：

``` rust
fn dead_end() -> ! {
    panic!("you have reached a dead code"); // panic！宏会导致程序崩溃，这意味着此函数保证用不返回。
}

fn forever() -> ! {
    loop { // loop将永远不会结束循环。这阻止了此函数返回。如果包含了break，编译就会出错，因为返回了（），需要修改返回值类型
        // ...
        break;
    }
}
```

#### 小结

- 有时候函数的签名会变得比较复杂，读懂这些复杂的函数签名需要一些耐心。
    - 小写字母（例如i、j）表示变量
    - 单个大写字母（例如T）表示泛型类型
    - 以大写字母开头的（例如Add）是trait的名字或者是具体类型的名字，比如String、Duration
    - 标签（例如'a）表示生命周期参数