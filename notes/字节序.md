#### 理解字节序

    在CPU层面存在着一些争论：组成整数的各个字节究竟该采取哪种方式来布局。有些人喜欢让字节从左到右排列，还有些人则喜欢让字节从右到左排列。这种布局上的选择被称为CPU字节序。有时候把一个可执行文件从一台计算机复制到另一台上后不能正常运行，字节序的不同是可能的原因之一。
    下面例子中的代码运行后大多数计算机上输出：-573785174 vs -1430532899。 若在稀奇古怪的硬件上执行，输出结果则会交换这两个数字的位置，即输出结果为 -1430532899 vs -573785174

``` rust
use std::mem::transmute;

fn main() {
    let big_endian: [u8; 4] = [0xAA, 0xBB, 0xCC, 0xDD];
    let little_endian: [u8; 4] = [0xDD, 0xCC, 0xBB, 0xAA];

    let a: i32 = unsafe { transmute(big_endian) };
    let b: i32 = unsafe { transmute(little_endian) };

    println!("{} vs {}", a, b);
}
output:
    -573785174 vs -1430532899
```

#### 大端序与小端序

- 将数字123分解为三个部分

| 分解    | 结果  |
|-------|-----|
| 100x1 | 100 |
| 20x1  | 20  |
| 3x1   | 3   |

- 当以常规的方式书写时，123就写作123，我们说这就是以大端序的方式来书写的。如果我们反转这个顺序，书写为321。那么这就是小端序的格式。
- 20世纪90年代，这个问题一直是个很大的问题。一些公司采用了"双端"
  （支持双向字节序）架构，而英特尔则选择了另外一种字节序，并且最终胜出了。所以如今几乎可以肯定地说，整数是以小端序来存储的。
- 除了多字节之间的序列单个字节内部也有一个类似问题。例如，一个u8类型的数值3，究竟该表示为0000_0011,还是表示为1100_0000呢？不过这种字节内部的排序不太可能会影响到你的日常编程。