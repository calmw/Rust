#### 介绍

- 每个浮点数在内存中的布局都是采用科学计数法的形式（1.89x10^12）。
- 采用科学计数法，用相同数量的字符就可以描述出具有巨大差异的尺度范围。利用这一点，计算机科学家们创建了一种固定宽度的编码格式，此格式可以对跨度非常大的数字进行编码。
- 采用科学技术发表示的数字分为几个不同的部分
    - 符号：可以用来表示负数
    - 尾数：又称为有效数字
    - 基数：又称为底数
    - 指数：描述了值的规模大小
- 一个浮点数包含了三个域，分别是符号为、指数、尾数。所有浮点数基数都为2，所以省略了。

#### rust f32类型的内存布局

- 一个符号位、8位指数位、23位尾数位
- f32内存布局结构图![f32.jpg](..%2Fimages%2Ff32.jpg)

#### 分离出符号位

- 要分离出符号位，就需要使用移位把其他的位都移走。对f32来说，就需要右移31位（>>31）,下面为代码示例

``` rust
fn main() {
    // 分离出符号位
    let n: f32 = 42.42;
    let n_bits: u32 = n.to_bits(); // 把f32的位模式解释为一个u32，以便执行后面操作
    let sign_bit = n_bits >> 31;
    println!("{} vs {}", n_bits, sign_bit);
}
fn main() {
  // 分离出指数，从一个f32中分离并解析出指数
  let n: f32 = 42.42;
  let n_bits: u32 = n.to_bits(); // 把f32的位模式解释为一个u32，以便执行后面操作
  let exponent_ = n_bits >> 23; // 把指数部分的8的位数据位执行右移位，覆盖尾数部分
  let exponent_ = exponent_ & 0xff; // 使用与掩码操作过滤符号位。只有最右边的8位位数据被保留下来
  let exponent = (exponent_ as i32) - 127; // 把保留下来的位数据解释成一个有符号整数，然后依据标准定义。还需要减去指数偏置量。

  println!("{} vs {}", n_bits, exponent);
}
 还有解析尾数部分，较为复杂，暂时省略
```

#### 浮点数不能比较

    程序中浮点数很多时候不能用二进制精确表示，就像1/3在十进制中无法精确表示一样。
    浮点数在rust中不能比较，因为会出现意外情况，不一定浮点数操作都会出现.下面的例子中，第一个通过了，第二个没有通过。go等其他语言一样。

``` rust
fn main() {
    assert_eq!(0.2 + 0.2, 0.4);
    assert_eq!(0.1 + 0.2, 0.3);
}
output:
    thread 'main' panicked at 'assertion failed: `(left == right)`
      left: `0.30000000000000004`,
     right: `0.3`', src/main.rs:3:5
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

####        